[{"content":"GitLens Features Gitlens simply helps you better understand code.Quicly glimpse into whom, why and when a line or code\nblock was changed. Jump back through history to gain furthur insights as to how and why the code evolved.\nEffortlessly explore the history and history and evolution of a codebase. Dive right in and see how Gitlens can help!.\nWhile Gitlen is powesful and feature rich, it is also highly customizable to meet your specific needs - Find code lens intrusive or the current line blame annotations distracting - no problem, it is quick and easy to turn them off or change how they behave via the build-in settings editor, an interactive editor covering many of Gitlens powerful settings. while for more advance customizations.\n ","description":"","id":1,"section":"posts","tags":["Development","Source Control"],"title":"GitLens Visual Studio code Extension","uri":"https://eduuh.github.io/posts/gitlens/"},{"content":"Algorithms What makes an algorithm fast? To answer this question, it tend to be grouped in two categories. With respect to input size\nand also assuming the worst case scenario.\n Time complexity Space Comlexity  Time complexity Here we answer the question of how many primitive operations are executed?\nTime complexity of an algorithm signifies the total time required by the program to run to completion. The tim complexity of algorithms is\nmore commonly expressed usind the big O notation.\nBig-O notation gives us an Industry-standard language to discuss the performance of algorithms. Not knowing how to speak this language\ncan make you stand out as an inexperienced programmer.\nSpace Complexity Here we are answering the question of How much memory is Used?\nProblem to think On Given a list of hotels return the price range of hotels in a given search result. Lets write the algorithm..\n1 2 3 4  var hotels = [ {price : 200, brand : \u0026#34;best eastern\u0026#34;} .... ]   solution We\u0026rsquo;d expect that the more data we have, the longer it will take to figure out the min and max required for the range.\nHowever, as our dataset grows, the cost can grow really fast or slow!\nApproch 1 : Compare all numbes to one another. As our data grows, how much does our work increases?\n   # of hotels (n) 3 5 10 100     #ops 9 25 100 1000   We can call this n^2 ,where n is the number of hotels. As n grows, the amount of work increases at that rate.        Approach two: Trach min \u0026amp; max How many comparison were made? We have to for loops each tracking the minimum and the max values.\nwe consider this 2*n because as the data grows, the number of work increase by 2.\nIts faster, less comparison are made for this.\nApproach 3: Sorted List Here you know where the min and max. We get the first and the last numbers.\n   # Operations Big-O Algorithm     n^2 (quadratic) compares all the numbers   2n (Linear) Find min and and max values   2 ,constant Sorted list find first and last    As the input grows.\nsuper fast\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt;super slow\n|Name |constant | logarithmic |linear | quadratic | exponential|\n|\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;-|\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\n|Notation|O(1) | O(logn) | O(n) | O(n^2) | O(e^n) |\ncheck out the big o chart\nNative Methods \u0026amp; JS Expressions Time complexities  Arrays : linear  1 2 3  const arr = [1,2,3] arr.pop() //=\u0026gt; {1,2]} arr[1] // dont need to start from index one, it know where the value is   Object : linear  1 2 3  const obj = {a: 1}; obj.a // -\u0026gt; 1    Calculating Time What to we do if we have multiple expressions/loops/etc?\n what about o(logn)?  A little better that linear.\nComplexity of Common Operations    complexity operation     O(1) Running a statement   O(1) value look-up on array, object,variable   O(logn) loop that cuts a problem in half every iteration   O(n) Looping through the value of an array   O(n^2) Double nested loops   O(n^3) Tripple nested loops    Space Complecity The space that it take up in the memory. Are you making a new\ndata structure how often are you doing that?.\n","description":"","id":2,"section":"posts","tags":["Js","DataStructures"],"title":"JavaScript Algorithm and Data Structures","uri":"https://eduuh.github.io/posts/jsargorithms/"},{"content":"This is a Java reference implementation of dynamic event-driven actors runtime aiming at providing adequate abstraction levels and mechanisms for modelling and developing (distributed) event-based systems. DERA leverages the intrinsic loose coupling of event-driven communication styles to support various kinds of run-time evolution and adaptation (i.e., enabling run-time flexibility) while minimizing the non-deterministic nature of traditional event-based applications (i.e., supporting formal analysis).\n","description":"Dynamic Event-Driven Actors","id":5,"section":"books","tags":null,"title":"Entity FrameWork Core","uri":"https://eduuh.github.io/books/dera/"},{"content":"Introduction A blog where i i will be writing on the following Technologies.\n React React Native Dotnet core Linux Terminal  Maintainer A Self Taught Developer : Edwin Muraya Currenty A BSC Geomatic and Geospartial Information System Student at Dedan Kimathi University\n","description":"","id":6,"section":"","tags":null,"title":"About Edds Blog","uri":"https://eduuh.github.io/about/"}]